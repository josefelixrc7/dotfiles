

GNU Autotools necesita a GNU M4 para la generación de scripts de configuración (configure scripts)

## Build a Project (Construyendo un proyecto)

### Creando un simple Makefile

Un Makefile es un archivo que contiene "reglas".

#### Características básicas de las reglas

```makefile
objetivo...: prerequisitos...
	receta ...
```

* `objetivo`: es mayormente el nombre de un archivo (mayormente son ejecutables o archivos objeto)
* `prerequisitos`: son archivos que son utilizados para crear a `objetivo`. Un objetivo a veces tiene mucho prerequisitos. Estos a veces no son necesarios
* `receta`: estas son acciones (o comandos). Estas comienzan por `tab` y luego los comandos

Al igual que las variables, las reglas tienen algunos nombres de objetivos que son comúnmente definidos:

- `all`: Hace todo
- `check`: Mejora algunos tests propios luego de la construcción del programa
- `clean`: elimina todos los archivos creados por Make
- `distclean`: Elimina más archivos que `clena`, puede borrar el Makefile mismo
- `dist`: Crea un paquete de distribución y lo comprime (en un tarball por ejemplo)
- `install`: instala el objetivo creado por Make, se necesita ser `root` para instalar en directorios del sistema
- `uninstall`: remove archivos instalados por Make

Ejemplo

```makefile
CC=gcc
CFLAGS=-g -Wall -I/usr/include/libxml2
LIBS=-lxml2

tuPrograma: main.o aux.o 
	$(CC) $(LIBS) main.o aux.o -o tuPrograma 

main.o: main.c
	$(CC) -c $(CFLAGS) main.c

aux.o: aux.c
	$(CC) -c $(CFLAGS) aux.c
	
clean:
	rm aux.o main.o \
	tuPrograma
```

#### Variables

* Se pueden definir variables como en cualquier lenguaje de la forma `variable=valor`
* Se puede obtener su valor de la forma `$(variable)` o `${variable}`
* `CC`: Program for compiling C programs, default 'cc'
* `CXX`: Program for compiling C++ programs, default 'g++'
* `CPP`: Program for running C preprocessor, default '$(CC) -E'
* `FC`: Program for running Fortran compiler, default 'f77'
* `RM`: Command to remove a file, default 'rm -f'
* `CFLAGS`: Extra flags for the C compiler
* `CXXFLAGS`: Extra flags for the C++ compiler
* `CPPFLAGS`: Extra flags for the C++ compiler
* `CFLAGS`: Extra flags for the Fortran compiler
* `LDFLAGS`: Extra flags for the linker

También se pueden definir variables para hacer más sencillo el proceso de crear un Makefile

Ejemplo

```makefile
CC=gcc
CFLAGS=-g -Wall -I/usr/include/libxml2
LIBS=-lxml2
objects= main.o aux.o

tuPrograma: $(objects)
	$(CC) $(LIBS) $(objects) tuPrograma 

main.o: main.c
	$(CC) -c $(CFLAGS) main.c

aux.o: aux.c
	$(CC) -c $(CFLAGS) aux.c
	
clean:
	rm $(objects) \
	tuPrograma
```

#### ¿Qué hace make?

1. Comienza por el primer objetivo (target) de un Makefile (o el único en una línea de comandos y buscando en una regla)
2. Si la regla no tiene prerequisitos, se ejecutan los comandos asociados y es todo.
3. Si tiene, antes de ejecutar cada comando, por cada prerequisito, Make mira por alguna regla que tenga ese prerequisito como objetivo (target) y repite el mismo proceso

Los programas mayormente instalados desde la fuente se instalan en `/usr/local/

#### Nombres básicos de un Makefile

* `GNUmakefile`
* `makefile`
* `Makefile`: este es el más recomendado

### Autotools

Si necesitas construir tu programa en otro sistema, usar Make podría ser algo muy complicado. El compilador C puede ser diferente, algunas funciones C podrían estar perdidas, tener otro nombre o el encabezado podría estar en otra dirección. 

Autotools está diseñado para solventar esto, en lo cual está involucrado un proceso arduo para la compilación de programas.

#### ¿Qué pasa cuándo usamos Autotools?

##### Input files (Archivos de entrada)

Un código fuente viene al menos con:
1. Un script de configuración llamado `configure`
2. Una plantilla de un Makefile `Makefile.in`: normalmente, en cada directorio del proyecto hay uno de estos
3. Hay muchos otros archivos pero no son necesarios (la mayoría son generados automáticamente)

###### `configure`

* No se necesita Autotools para construir un paquete de Autotools
* `configure` es un shell script del tipo `sh`
* Este archivo comprueba tu sistema y escribe Makefiles de las plantillas

Proceso de `configure`

(Makefile1.in, Makefile2.in, MakefileN.in) -> configure -> (Makefile1, Makefile2, Makefile3)

`configure` acepta varias opciones en la línea de comandos, estas opciones son usadas para instalar los archivos en directorios diferentes, deshabilitar partes del proyecto (para obtener un ejecutable más pequeño). Se puede obtener una lista de opciones usando `configure --help`

Algunas opciones son

* `--help`: muestra las opciones y ayuda
* `--host=sistema_otro`: compila o ejecuta en otro sistema (multiplataforma)
* `--prefix=dir`: selecciona el directorio raíz donde se hará la instalación 


Notas

* `configure` usa como directorio de construcción, el mismo directorio donde se esté ejeutando este script

##

Una dependencia es otro software o programa necesario por un software en específico para funcionar

* `dependencia`: el programa se ejecuta usando esta dependecia
* `dependencia-devel`: el programa se construye usando esta dependencia

###### `make`

Los Makefiles creados por `configure` son un poco más complicados pero son Makefiles normales. 

## Creando un proyecto

* Autotools no es necesario para compilar un proyecto
* Autotools está compuesto de varias herramientas:
  * `aclocal`
  * `autoconf`: es usado para generar el `configure script`, de una plantilla llamada `configure.ac`. Este script chequeará todas las características del sistema host y generará todos los Makefile desde de la plantilla de `Makefile.in`
  * `automake`: es usado para generar las plantillas `Makefile.in`, siguiendo los estandares de GNU, desde las plantillas `Makefile.am`

### Flujo de trabajo de Autotools

​             v-------------------------------------------------- `autoconf` -> `configure`

`configure.ac` -> `aclocal` -> `aclocal.m4` --------^v

*`Makefile.am` ------------------------------------------> `automake` -> `Makefile.in`

### Pasos para crear un proyecto

#### 1. Escribiendo las fuentes



#### 2. Ejecutando Autoconf



Makefile.am contiene instrucciones de Automake

configure.ac contiene instrucciones de Autoconf para crear el `configure script`



Autoconf está encargado de crear a `configure` de `configure.ac`

Automake se encarga de crear *`Makefile.in` de *`Makefile.am` y de `Makefile.ac` (esto es importante saberlo, no indicará qué manual buscar cuando tengamos preguntas)



## Empaquetando software

### Forma simple

1. Crea una directorio con el nombre de tu software
2. Crea un directorio `src`
3. Dentro del directorio `src` escribe tus códigos fuentes (`main.cpp`, `class.cpp`, etc.). A estos, hay que incluirles el header `config.h`. Si es en C++ con `#include "config.h"`
4. En el directorio del software, añade el archivo `README`
5. Crea un `Makefile.am` en cada directorio (princpal y `src` en este caso), deben de contener algo similar a:

`src/Makefile.am`:

```makefile
bin_PROGRAMS = tuSoftware
tu_software_SOURCES = main.c
```

`Makefile.am`:

```makefile
dist_doc_DATA = README
```

6. Crea un `configure.ac` que contendrá instrucciones de Autoconf para crear el `configure script`:

`configure.ac`:

```
AC_INIT([tuSoftware], [1.0], [correo@servidor])
AM_INIT_AUTOMAKE([-Wall -Werror foreign])
AC_PROG_CC
AC_CONFIG_HEADERS([config.h])
AC_CONFIG_FILES([
	Makefile
	src/Makefile
])
AC_OUTPUT
```

7. Corre Autoreconf:

```bash
$ autoreconf --install
```

8. Hasta este punto, el sistema de construcción está completo. Autoreconf añade archivos como `configure`, `config.h.in`, `Makefile.in`.
9. Ejecutamos el `configure script` con:

```bash
$ ./configure
```

10. Ejecutamos `make` para compilar

```bash
$ make
```

11. Creamos los tarballs

```bash
$ make distcheck
```

* NOTAS
  * Ejecutar autoreconf solo es necesario cuando no el GNU Build System no existe. 
  * Cuando cambias o modificas archivos como `configure.ac` o `Makefile.am`, la parte relevante del sistema de construcción es regenerada cuando se ejecuta `make`
  * `autoreconf` es un script que llama a Automake, Autconf y a otras herramientas más.

### Explicación de la forma simple

#### 1. Creando el `Makefile.am`



#### 2. Creando el `configure.ac`





### Añadiendo una librería

#### 1. Usando `pkg-config` 

* Esta es una herramienta para desarrolladores que consulta por librerías instaladas y sus versiones y todas las opciones necesarias para el compilado y enlazado
* Esta viene con un macro de Autoconf llamado `PKG_CHECK_MODULES`, agregamos lo siguiente a nuestro proyecto:

En `configure.ac`:

```makefile
PKG_CHECK_MODULES(LIBRERIA, libreria-1.0 >= 1.4)
```

`LIBRERIA` es un nombre definido por el usuario. Esta creará dos variables: `LIBRERIA_CFLAGS` y `LIBRERIA_LIBS`

* Podemos chequear todas las librerías instaladas en nuestro sistema con `pkg-config --list-all`

En `Makefile.am`:

```makefile
LIBRERIA_CPPFLAGS = $(XML_CFLAGS)
LIBRERIA_LDFLAGS= $(XML_LIBS)
```

#### 2. Usando un macro de Autoconf

Hay varias formas de añadir un macro de Autoconf

* Busca en `/usr/share/aclocal/` y busca un archivo que se llame como la librería pero con extensión `.m4`, si no la tienes, puedes buscarla y copiarlar allí.
* Para usar un macro solo tienes que mirar dentro de él y ver cómo usarlo (Mayormente en los comentarios se puede ver la variable que debemos usar)
* Añadimos lo siguiente a los archivos

`configure.ac`:

```
VARIABLE_LIBRERIA(2.4.0)
```

Esto creará dos variables llamadas `VARIABLE_LIBRERIA_CPPFLAGS` y `VARIABLE_LIBRERIA_LIBS`

`Makefile.am`:

```makefile
tu_software_CPPFLAGS = $(VARIABLE_LIBRERIA_CPPFLAGS)
tu_software_LDFLAGS= $(VARIABLE_LIBRERIA_LIBS)
```

* Ejecutar `make` nuevamente para generar todos los archivos

#### 3. Con una dirección específica

En este caso se añaden las rutas específicas que están en el sistema anfitrión (host).

En el `Makefile.am`:

```makefile
tu_software_CPPFLAGS = -I /usr/include/tu_libreria
tu_software_LDFLAGS= -ltu_libreria_so
```



Cada `Makefile.am` es una serie de definiciones de variables de `make`, en ocasiones estableciendo reglas

Cuando un paquete necesita ser construido en otro sistema, entonces, el `Makefile` debe de ser ajustado

Autotools es un conjunto de herramientas que crearán un sistema de construcción GNU para tu paquete.

## Instalación básica

1. Descomprimimos el paquete (o desempacamos)

```bash
$ tar -zxvf programa-v1.0.0.tar.gz
```

Suponiendo que está comprimido con GNU gzip

2. Configuramos

```bash
$ ./configure
```

Esto a veces es preferible hacerlo dentro de una carpeta aparte dentro del paquete

3. Compilamos y construimos todas las librerías y scripts que necesita el programa

```bash
$ make
```

4. Probamos antes de instalar

```bash
$ make check
```

5. Instalamos en el sistema

```bash
$ sudo  make install
```

Esto lo que hará será copiar todos los programas, librerías, header files, scripts y otras informaciones de archivos del directorio fuente al destino en el sistema. Por defecto todo es instalados en subdirectorios de `/usr/local/`:

* `/usr/local/bin`: todos los binarios
* `/usr/local/lib`: librerías
* `/usr/local/share/doc/`: documentos como README

6. Verificamos los archivos copiados

```bash
$ sudo make installcheck
```



### Variables de directorios estandar

| Variable    | Valor por defecto             |
| ----------- | ----------------------------- |
| prefix      | /usr/local                    |
| exec_prefix | ${prefix}                     |
| bindir      | ${exec_prefix}/bin            |
| libdir      | ${exec_prefix}/lib            |
| includedir  | ${prefix}/include             |
| datarootdir | ${prefix}/share               |
| datadir     | ${datarootdir}                |
| mandir      | ${datarootdir}/man            |
| infodir     | ${datarootdir}/info           |
| docdir      | ${datarootdir}/doc/${PACKAGE} |

## Variables de configuración estandar

| Variable | Uso                                                          |
| -------- | ------------------------------------------------------------ |
| CC       | C compiler command (Comando del compilador C)                |
| CFLAGS   | C compiler flags (Banderas del compilador C)                 |
| CXX      | C++ compiler command (Comando del compilador C++)            |
| CXXFLAGS | C++ compiler flags (Banderas del compilador C´)              |
| LDFLAGS  | linker flags (Banderas del enlazador)                        |
| CPPFLAGS | C/C++ preprocessor flags (Banderas del preprocesador de C/C++) |

## Árboles paralelos de construcción

El GNU Build System define dos árboles:

1. Source tree: árbol fuente, este contiene todos los archivos fuentes
2. Build tree: árbol de construcción, está direccionado dónde `configure` sea ejecutado. Este está lleno de objects files (archivos objeto), librerías y otros archivos derivados de la fuente. Este árbol mayormente tiene la misma disposición de subdirectorios que el Source tree

* Nota: si `configure` es ejecutado en el mismo lugar donde ese el Source tree, entonces ambos árboles estarán combinados. Para evitar esto mayormente se construye en un directorio llamado `build` que debe crearse

## Cross compilation

La cross-compilation es el construir un software en una plataforma y ejecutar el binario en otra plataforma. Hay dos argumentos importantes:

* `--build=sistema`: es el sistema en el que el programa en construido
* `--host=sistema`: es el programa en el cual el sistema es ejecutado

Ejemplo

```bash
./configure --build i686-pc-linux-gnu --host i586-mingw32msvc
```

Esto crea un ejecutable de 32 bits para MS Windows.

## Renombrando programas al momento de instalar

* `--program-prefix=prefix`: prefijo para el nombre del programa
* `--program-suffix=suffix`: Sufijo para los nombres de los programas instaladosAppend suffix to installed program names.
* `--program-transform-name=program`: Run sed program on installed program names.

Ejemplo

```bash
./configure --program-prefix test-
...
make
...
sudo make install
```



GNU Build System no reemplaza a un administrador de paquetes