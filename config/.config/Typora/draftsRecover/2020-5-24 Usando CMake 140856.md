# Usando CMake



## Instalando software

1. Si nuestra versión de `cmake` es mayor o igual a la 3.15, ejecutamos:

```bash
cd programa-1.0.0
mkdir build
cd build
cmake ..
cmake --build .
cmake --build . --target install
```

2. Si lo anterior no funcionó por algún error, ejecutamos:

```bash
cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local
cmake --build .
sudo cmake --build . --target install
```

3. Si nuestra versión de `cmake` es menor a 3.15, ejecutamos:

```bash
cmake ..
cmake --build .
sudo make install
```

## Uso básico

1. Creamos el directorio de nuestro proyecto

```bash
cd ~ ; mkdir test1 ; cd test1
```

2. Creamos nuestro código fuente sencillo

Este debe de estar compuesto de un archivo .cpp, en el cual esté la función `int main()`

3. Creamos nuestro `CMakeLists.txt`

```bash
touch CMakeLists.txt && vim CMakeLists.txt
```

Agregamos la versión mínima requerida de CMake

```CMake
cmake_minimum_required(VERSION 3.10)
```

Agregamos el título del proyecto (será el del ejecutable) y su versión

```CMake
project(Tutorial VERSION 1.0)
```

Agregamos el ejecutable y el código fuente responsable principal (donde esté la función `int main()`

```CMake
add_executable(${PROJECT_NAME} Tutorial.cxx)
```

Agregamos el header de configuración

```CMake
configure_file(Config.h.in Config.h)
```

Agregamos el directorio principal a la lista de de rutas para buscar direcciones de inclusión

```CMake
target_include_directories(
    ${PROJECT_NAME} PUBLIC
    "${PROJECT_BINARY_DIR}"
)
```

Agregamos los estandares de C++ (puede ser desde el C++11)

```CMake
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)
```

4. Creamos el header de configuración

```bash
touch TutorialConfig.h && vim TutorialConfig.h
```

Muchas veces, ese archivo debe de terminar en `.h.in`

En este caso, `TutorialConfig.h`:

```c
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
```

5. Icluimos el header de configuración a nuestro código fuente principal

```c++
#include "TutorialConfig.h"
```

## Construcción básica

1. Si el archivo está comprimido, descomprimimos y entramos al directorio principal

```bash
tar -zxvf test1.tar.gz
cd test1
```

2. Preparamos para compilar

```cmake
mkdir Debug ; cd Debug
cmake ../
```

3. Compilamos y ejecutamos

```bash
cmake --build .
./test1
```

## Trabajando con una biblioteca

La idea principal es que las bibliotecas contengan todas las funciones y clases importantes de nuestro programa

1. Creamos el proyecto básico

2. Creamos directorio para la biblioteca

```bash
mkdir Biblioteca
```

2. Creamos la biblioteca o librería

Esta debe de constar de un archivo .cpp y un header .h y un `CMakeLists.txt`

Enlazamos archivos al `Biblioteca/CMakeLists.txt`:

```CMake
add_library(Biblioteca Biblioteca.cpp)
```

3. Añadimos la biblioteca a `CMakeLists.txt` principal

Añadimos el directorio de la biblioteca

```CMake
add_subdirectory(Biblioteca)
```

Enlazamos la biblioteca

```CMake
target_link_libraries(${PROJECT_NAME} PUBLIC Biblioteca)
```

Agregamos el directorio a la lista de de rutas para buscar direcciones de inclusión

```CMake
target_include_directories(
	${PROJECT_NAME} PUBLIC
	"${PROJECT_BINARY_DIR}"
	"${PROJECT_SOURCE_DIR}/Biblioteca"
)
```

4. Hacemos la biblioteca opcional (si el proyecto es grande)

Añadimos al `CMakeLists.txt` principal

```CMake
option(USE_MYMATH "Use tutorial provided math implementation" ON)
```

Agregamos la definición de encabezado si está definida en `Tutorial.cxx`:

```c++
#ifdef USE_MIBIBLIOTECA
#  include "Biblioteca.h"
#endif
```

Añadimos la definición al header de configuración:

```c
#cmakedefine USE_MIBIBLIOTECA
```

5. Hacemos la biblioteca condicional (si lo necesitamos)

Cambiamos en nuestro `CMakeLists.txt` principal:

```CMake
if(USE_MYMATH)
	add_subdirectory(Biblioteca)
	list(APPEND EXTRA_LIBS Biblioteca)
	list(APPEND EXTRA_INCLUDES "${PROJECT_SOURCE_DIR}/Biblioteca")
endif()
```

Cambiamos el contenido de `target_link_libraries()` por:

```CMake
target_link_libraries(${PROJECT_NAME} PUBLIC ${EXTRA_LIBS})
```

Cambiamos el contenido de `target_include_directories()` por:

```CMake
target_include_directories(
	${PROJECT_NAME} PUBLIC
	"${PROJECT_BINARY_DIR}"
	${EXTRA_INCLUDES}
)
```

Añadimos lo siguiente al header de configuración:

```c
#cmakedefine USE_MIBIBLIOTECA
```

6. Compilación básica

## Añadiendo una biblioteca (forma actual)

1. Añadimos al final de `Biblioteca/CMakeLists.txt`:

```cmake
target_include_directories(
	Biblioteca
	INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}
)
```

2. Eliminamos los usos de la variable `EXTRA_INCLUDES` del `CMakeLists.txt` principal

Esta variable se usa en la condición de uso de la biblioteca y en `target_include_directories()`

## Añadiendo reglas

1. Añadimos donde serán instalados los archivos, al final de `Biblioteca/CMakeLists.txt` añadimos:

```cmake
install(TARGETS Biblioteca DESTINATION lib)
install(FILES Biblioteca.h DESTINATION include)
```

2. Añadimos donde será instalado el ejecutable y demás archivos, al final del archivo `CMakeLists.txt` principal añadimos:

```cmake
install(TARGETS ${PROJECT_NAME} DESTINATION bin)
install(
	FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h" DESTINATION include
)
```

3. Establecemos la variable qué establece la raíz de donde los archivos serán instalados añadiendo al final del archivo  `CMakeLists.txt` principal 

```cmake
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "/usr/local" CACHE PATH "..." FORCE)
endif()
```

4. Instalamos

## Usando dependencias

Para usar dependencias (tales como GTK, GTKmm, qt, TLKT, entre otros), debemos hacer lo siguiente:

1. Añadimos `pkg-config` al `CMakeLists.txt` principal

```cmake
include(FindPkgConfig)
find_package(PkgConfig REQUIRED)
```

2. Buscamos la dependencia (en este ejemplo, GTKmm)

```cmake
pkg_search_module(GTKMM REQUIRED gtkmm-3.0)
```

3. Incluimos los directorios y enlazamos la dependecia

```cmake
INCLUDE_DIRECTORIES(${GTKMM_INCLUDE_DIRS})
LINK_DIRECTORIES(${GTKMM_LIBRARY_DIRS})
```

4. Enlazamos la librería al proyecto

```cmake
TARGET_LINK_LIBRARIES(${PROJECT_NAME} ${GTKMM_LIBRARIES})
```

## Uso distribuido

Es para ser usado con distintos directorios de carpetas

```
|--Principal
   |--CMakeLists.txt
   |--src
      |--CMakeLists.txt
      |--Biblioteca1.cpp
      |--Biblioteca2.cpp
      |--BibliotecaN.cpp
      |--main.cpp
   |--include
      |--Biblioteca1.h
      |--Biblioteca2.h
      |--BibliotecaN.h
```

1. Seguimos todo lo del capítulo de **Uso básico** y **Usando dependencias**
2. Agregamos los directorios a incluir en el `CMakeLists.txt` principal

```cmake
set(HEADER ${CMAKE_SOURCE_DIR}/include)
include_directories(include)
add_subdirectory(src)
```

*La variable `HEADER` funciona para indicar el directorio donde estén los archivos de cabecera*

3. Establecemos configuraciones para añadir bibliotecas en `src/CmakeLists.txt`

Establecemos variables de las fuentes de las bibliotecas

```cmake
set(BIBLIOTECA1_FUENTE
    Biblioteca1.cpp 
    ${HEADER}/Biblioteca1.h
)
set(BIBLIOTECA2_FUENTE
    Biblioteca2.cpp 
    ${HEADER}/Biblioteca2.h
)
set(BIBLIOTECAN_FUENTE
    BibliotecaN.cpp 
    ${HEADER}/BibliotecaN.h
)
```

Añadimos las bibliotecas (Esta puede ser `STATIC`, `SHARED` o `OBJECT`)

```cmake
add_library(BIBLIOTECA1 STATIC ${BIBLIOTECA1_FUENTE})
add_library(BIBLIOTECA2 SHARED ${BIBLIOTECA2_FUENTE})
add_library(BIBLIOTECAN SHARED ${BIBLIOTECAN_FUENTE})
```

Si la biblioteca necesita una dependecia agregamos:

```cmake
target_link_libraries(
    BIBLIOTECA2
    ${GTKMM_LIBRARIES}
)
target_include_directories(BIBLIOTECA2 PUBLIC ${GTKMM_INCLUDE_DIRS})
target_compile_options(BIBLIOTECA2 PUBLIC ${GTKMM_CFLAGS_OTHERS})
```

4. Añadimos la biblioteca al proyecto

Añadiendo en `src/CMakeLists.txt`:

```cmake
target_link_libraries(${PROJECT_NAME} PUBLIC BIBLIOTECA1)
target_link_libraries(${PROJECT_NAME} PUBLIC BIBLIOTECA2)
target_link_libraries(${PROJECT_NAME} PUBLIC BIBLIOTECAN)
```

## Notas

* Diferencia entre `CMAKE_CURRENT_SOURCE_DIR` y `CMAKE_CURRENT_LIST_DIR`

Las variables `CMAKE_CURRENT_SOURCE_DIR` y `CMAKE_CURRENT_LIST_DIR` pueden referirse a diferentes directorios para un archivo de lista CMake que está incluido por otro archivo con el comando de inclusión. Por ejemplo, si un CMakeLists.txt está presente en un proyecto de directorio y contiene la siguiente directiva

```cmake
include (src/CMakeLists.txt)
```

luego, mientras se procesa `src/CMakeLists.txt`, `CMAKE_CURRENT_LIST_DIR` se referirá a `project /` src mientras que `CMAKE_CURRENT_SOURCE_DIR` aún señala al proyecto del directorio externo.

`CMAKE_CURRENT_LIST_DIR` es útil cuando necesita ubicar archivos de recursos como archivos de plantilla o scripts por lotes que se encuentran al lado del archivo `CMakeLists.txt` que se está procesando actualmente.

